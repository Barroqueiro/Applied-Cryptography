from collections import deque
import sys
import hashlib

# Shuffled sbox
shuffledsbox = []

# Suffled sbox inverted
shuffledrsbox = []

# All 11 keys    
keys = []

# Shuffle key
sk = []

#Precomputed sbox
sbox = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)

#Precomputed inverse sbox
rsbox = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)

lookup_galois = {}

lookup_galois[1] = [i for i in range(256)]

lookup_galois[2] = [0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5]

lookup_galois[9] = [0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46]

lookup_galois[3] = [0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a]

lookup_galois[11] = [0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3]

lookup_galois[13] = [0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97]

lookup_galois[14] = [0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d]

mix_c = [[2,3,1,1],
         [1,2,3,1],
         [1,1,2,3],
         [3,1,1,2]]

mix_ci = [[14,11,13,9],
            [9,14,11,13],
            [13,9,14,11],
            [11,13,9,14]]

#Precomputed permutations of tuples of 4 with elements ranging from 0 to 3 with no repetitions
permutations = [
    (0,1,2,3),
    (0,1,3,2),
    (0,2,1,3),
    (0,2,3,1),
    (0,3,2,1),
    (0,3,1,2),
    (1,0,2,3),
    (1,0,3,2),
    (1,2,0,3),
    (1,2,3,0),
    (1,3,2,0),
    (1,3,0,2),
    (2,1,0,3),
    (2,1,3,0),
    (2,0,1,3),
    (2,0,3,1),
    (2,3,0,1),
    (2,3,1,0),
    (3,1,2,0),
    (3,1,0,2),
    (3,2,1,0),
    (3,2,0,1),
    (3,0,2,1),
    (3,0,1,2),
]

#Precomputed Rcon
Rcon = [0x00, 0x01, 0x02,
		0x04, 0x08, 0x10, 
		0x20, 0x40, 0x80, 
		0x1b, 0x36]

#Matching hexadecimal with decimal
def hex_matcher(l):
    return {
        "0":0,
        "1":1,
        "2":2,
        "3":3,
        "4":4,
        "5":5,
        "6":6,
        "7":7,
        "8":8,
        "9":9,
        "a":10,
        "b":11,
        "c":12,
        "d":13,
        "e":14,
        "f":15
    }[l]

"""
    xor_rcon()

    Params:
        - list1
        - lis2
    Walkthrough:
        - Xor elements of both lists

"""

def xor_rcon(l, r):
    return [l[i] ^ r[i] for i in range(4)]
		
"""
    SubWord()

    Params:
        - word (word for key creation)

    Walkthrough:
        - Creation fo empty word
        - Loop through the word passed as argument
        - Get the decimal value of each part of the word and sub it using the s box
        - Append values to new word and return it

"""

def SubWord(word):
    return [sbox[e] for e in word]


"""
    keyExpansion()

    Params:
        - key (Key to be expanded)

    Walkthrough:
        - Creation of the empty list that will hold all 44 words
        - Fill the first 4 words from the key
        - Create the following keys by using the previous ones, if it's a multiple of 4 also perform rotword and 
            subword before the xor

"""

def keyExpansion(key):

	w = [[]]*44

	for i in range(4):
		w[i] = (key[4*i], key[4*i+1], key[4*i+2], key[4*i+3])
		
	for i in range(4, 44):
		temp = w[i-1]
		word = w[i-4]   

		if i % 4 == 0:
			x = shift_list(temp,1)
			y = SubWord(x)
			rcon = Rcon[int(i/4)]
			temp = xor_rcon(y, [rcon,0,0,0]) 
		
		xord = xor_rcon(word, temp)		
		w[i] = (xord[0], xord[1], xord[2], xord[3])
	return w


"""
    print_block() and print_block_ord()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        Debugging function used for printing blocks

"""

def print_block(block):
    print("---------------")
    for i in range(4):
        print("{:<3} {:<3} {:<3} {:<3}".format(chr(block[i][0]),chr(block[i][1]),chr(block[i][2]),chr(block[i][3])))
    print("---------------")

def print_block_ord(block):
    print("---------------")
    for i in range(4):
        print("{:<3} {:<3} {:<3} {:<3}".format(block[i][0],block[i][1],block[i][2],block[i][3]))
    print("---------------")

"""
    sub_bytes()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get the sbox
        - Switch each byte for the corresponding one in the sbox
        - Return the block

"""

def sub_bytes(block):
    return [[sbox[x] for x in line] for line in block]

"""
    inv_sub_bytes()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get the rsbox
        - Switch each byte for the corresponding one in the rsbox
        - Return the block

"""

def inv_sub_bytes(block):
    return [[rsbox[x] for x in line] for line in block]

"""
    shift_list()

    Params:
        - l (List to shift)
        - offset (Shift to apply)

    Walkthrough:
        - Split the list from the offset to the end and from the start to the offst and return the concat of 
            both lists

"""

def shift_list(l,offset):
    return l[offset:] + l[:offset]

"""
    shift_rows()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Set the offsets for each row
        - Shift each row with the shift_list function
        - Return the block

"""

def shift_rows(block):
    block[1] = block[1][1:] + block[1][:1]
    block[2] = block[2][2:] + block[2][:2]
    block[3] = block[3][3:] + block[3][:3]
    return block

"""
    inv_shift_rows()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Set the offsets for each row (Inverse of shift_rows())
        - Shift each row with the shift_list function
        - Return the block

"""

def inv_shift_rows(block):
    block[1] = shift_list(block[1],3)
    block[2] = shift_list(block[2],2)
    block[3] = shift_list(block[3],1)
    return block


def mix_columns(block):
    block_res = [[0,0,0,0],
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0]]
    block_res[0][0] = lookup_galois[mix_c[0][0]][block[0][0]] ^ lookup_galois[mix_c[0][1]][block[1][0]] ^ lookup_galois[mix_c[0][2]][block[2][0]] ^ lookup_galois[mix_c[0][3]][block[3][0]]
    block_res[1][0] = lookup_galois[mix_c[1][0]][block[0][0]] ^ lookup_galois[mix_c[1][1]][block[1][0]] ^ lookup_galois[mix_c[1][2]][block[2][0]] ^ lookup_galois[mix_c[1][3]][block[3][0]]
    block_res[2][0] = lookup_galois[mix_c[2][0]][block[0][0]] ^ lookup_galois[mix_c[2][1]][block[1][0]] ^ lookup_galois[mix_c[2][2]][block[2][0]] ^ lookup_galois[mix_c[2][3]][block[3][0]]
    block_res[3][0] = lookup_galois[mix_c[3][0]][block[0][0]] ^ lookup_galois[mix_c[3][1]][block[1][0]] ^ lookup_galois[mix_c[3][2]][block[2][0]] ^ lookup_galois[mix_c[3][3]][block[3][0]]
    block_res[0][1] = lookup_galois[mix_c[0][0]][block[0][1]] ^ lookup_galois[mix_c[0][1]][block[1][1]] ^ lookup_galois[mix_c[0][2]][block[2][1]] ^ lookup_galois[mix_c[0][3]][block[3][1]]
    block_res[1][1] = lookup_galois[mix_c[1][0]][block[0][1]] ^ lookup_galois[mix_c[1][1]][block[1][1]] ^ lookup_galois[mix_c[1][2]][block[2][1]] ^ lookup_galois[mix_c[1][3]][block[3][1]]
    block_res[2][1] = lookup_galois[mix_c[2][0]][block[0][1]] ^ lookup_galois[mix_c[2][1]][block[1][1]] ^ lookup_galois[mix_c[2][2]][block[2][1]] ^ lookup_galois[mix_c[2][3]][block[3][1]]
    block_res[3][1] = lookup_galois[mix_c[3][0]][block[0][1]] ^ lookup_galois[mix_c[3][1]][block[1][1]] ^ lookup_galois[mix_c[3][2]][block[2][1]] ^ lookup_galois[mix_c[3][3]][block[3][1]]
    block_res[0][2] = lookup_galois[mix_c[0][0]][block[0][2]] ^ lookup_galois[mix_c[0][1]][block[1][2]] ^ lookup_galois[mix_c[0][2]][block[2][2]] ^ lookup_galois[mix_c[0][3]][block[3][2]]
    block_res[1][2] = lookup_galois[mix_c[1][0]][block[0][2]] ^ lookup_galois[mix_c[1][1]][block[1][2]] ^ lookup_galois[mix_c[1][2]][block[2][2]] ^ lookup_galois[mix_c[1][3]][block[3][2]]
    block_res[2][2] = lookup_galois[mix_c[2][0]][block[0][2]] ^ lookup_galois[mix_c[2][1]][block[1][2]] ^ lookup_galois[mix_c[2][2]][block[2][2]] ^ lookup_galois[mix_c[2][3]][block[3][2]]
    block_res[3][2] = lookup_galois[mix_c[3][0]][block[0][2]] ^ lookup_galois[mix_c[3][1]][block[1][2]] ^ lookup_galois[mix_c[3][2]][block[2][2]] ^ lookup_galois[mix_c[3][3]][block[3][2]]
    block_res[0][3] = lookup_galois[mix_c[0][0]][block[0][3]] ^ lookup_galois[mix_c[0][1]][block[1][3]] ^ lookup_galois[mix_c[0][2]][block[2][3]] ^ lookup_galois[mix_c[0][3]][block[3][3]]
    block_res[1][3] = lookup_galois[mix_c[1][0]][block[0][3]] ^ lookup_galois[mix_c[1][1]][block[1][3]] ^ lookup_galois[mix_c[1][2]][block[2][3]] ^ lookup_galois[mix_c[1][3]][block[3][3]]
    block_res[2][3] = lookup_galois[mix_c[2][0]][block[0][3]] ^ lookup_galois[mix_c[2][1]][block[1][3]] ^ lookup_galois[mix_c[2][2]][block[2][3]] ^ lookup_galois[mix_c[2][3]][block[3][3]]
    block_res[3][3] = lookup_galois[mix_c[3][0]][block[0][3]] ^ lookup_galois[mix_c[3][1]][block[1][3]] ^ lookup_galois[mix_c[3][2]][block[2][3]] ^ lookup_galois[mix_c[3][3]][block[3][3]]
    return block_res

def inv_mix_columns(block):
    block_res = [[0,0,0,0],
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0]]
    block_res[0][0] = lookup_galois[mix_ci[0][0]][block[0][0]] ^ lookup_galois[mix_ci[0][1]][block[1][0]] ^ lookup_galois[mix_ci[0][2]][block[2][0]] ^ lookup_galois[mix_ci[0][3]][block[3][0]]
    block_res[1][0] = lookup_galois[mix_ci[1][0]][block[0][0]] ^ lookup_galois[mix_ci[1][1]][block[1][0]] ^ lookup_galois[mix_ci[1][2]][block[2][0]] ^ lookup_galois[mix_ci[1][3]][block[3][0]]
    block_res[2][0] = lookup_galois[mix_ci[2][0]][block[0][0]] ^ lookup_galois[mix_ci[2][1]][block[1][0]] ^ lookup_galois[mix_ci[2][2]][block[2][0]] ^ lookup_galois[mix_ci[2][3]][block[3][0]]
    block_res[3][0] = lookup_galois[mix_ci[3][0]][block[0][0]] ^ lookup_galois[mix_ci[3][1]][block[1][0]] ^ lookup_galois[mix_ci[3][2]][block[2][0]] ^ lookup_galois[mix_ci[3][3]][block[3][0]]
    block_res[0][1] = lookup_galois[mix_ci[0][0]][block[0][1]] ^ lookup_galois[mix_ci[0][1]][block[1][1]] ^ lookup_galois[mix_ci[0][2]][block[2][1]] ^ lookup_galois[mix_ci[0][3]][block[3][1]]
    block_res[1][1] = lookup_galois[mix_ci[1][0]][block[0][1]] ^ lookup_galois[mix_ci[1][1]][block[1][1]] ^ lookup_galois[mix_ci[1][2]][block[2][1]] ^ lookup_galois[mix_ci[1][3]][block[3][1]]
    block_res[2][1] = lookup_galois[mix_ci[2][0]][block[0][1]] ^ lookup_galois[mix_ci[2][1]][block[1][1]] ^ lookup_galois[mix_ci[2][2]][block[2][1]] ^ lookup_galois[mix_ci[2][3]][block[3][1]]
    block_res[3][1] = lookup_galois[mix_ci[3][0]][block[0][1]] ^ lookup_galois[mix_ci[3][1]][block[1][1]] ^ lookup_galois[mix_ci[3][2]][block[2][1]] ^ lookup_galois[mix_ci[3][3]][block[3][1]]
    block_res[0][2] = lookup_galois[mix_ci[0][0]][block[0][2]] ^ lookup_galois[mix_ci[0][1]][block[1][2]] ^ lookup_galois[mix_ci[0][2]][block[2][2]] ^ lookup_galois[mix_ci[0][3]][block[3][2]]
    block_res[1][2] = lookup_galois[mix_ci[1][0]][block[0][2]] ^ lookup_galois[mix_ci[1][1]][block[1][2]] ^ lookup_galois[mix_ci[1][2]][block[2][2]] ^ lookup_galois[mix_ci[1][3]][block[3][2]]
    block_res[2][2] = lookup_galois[mix_ci[2][0]][block[0][2]] ^ lookup_galois[mix_ci[2][1]][block[1][2]] ^ lookup_galois[mix_ci[2][2]][block[2][2]] ^ lookup_galois[mix_ci[2][3]][block[3][2]]
    block_res[3][2] = lookup_galois[mix_ci[3][0]][block[0][2]] ^ lookup_galois[mix_ci[3][1]][block[1][2]] ^ lookup_galois[mix_ci[3][2]][block[2][2]] ^ lookup_galois[mix_ci[3][3]][block[3][2]]
    block_res[0][3] = lookup_galois[mix_ci[0][0]][block[0][3]] ^ lookup_galois[mix_ci[0][1]][block[1][3]] ^ lookup_galois[mix_ci[0][2]][block[2][3]] ^ lookup_galois[mix_ci[0][3]][block[3][3]]
    block_res[1][3] = lookup_galois[mix_ci[1][0]][block[0][3]] ^ lookup_galois[mix_ci[1][1]][block[1][3]] ^ lookup_galois[mix_ci[1][2]][block[2][3]] ^ lookup_galois[mix_ci[1][3]][block[3][3]]
    block_res[2][3] = lookup_galois[mix_ci[2][0]][block[0][3]] ^ lookup_galois[mix_ci[2][1]][block[1][3]] ^ lookup_galois[mix_ci[2][2]][block[2][3]] ^ lookup_galois[mix_ci[2][3]][block[3][3]]
    block_res[3][3] = lookup_galois[mix_ci[3][0]][block[0][3]] ^ lookup_galois[mix_ci[3][1]][block[1][3]] ^ lookup_galois[mix_ci[3][2]][block[2][3]] ^ lookup_galois[mix_ci[3][3]][block[3][3]]

    return block_res

"""
    xor_adr()

    Params:
        - s (int from the block to be xord)
        - h (int from the key)

    Walkthrough:
        - Return of both ints

"""

def xor_adr(s,h):
    return h ^ s

"""
    xor_round_key()

    Params:
        - block (List representation of the 16 bytes to create a block)
        - Key (Key to xor with the block)

    Walkthrough:
        - Create an empty matrix of 4 x 4 for the key and apped from the key
        - Create matrix for the xor
        - Apped to this matrix using the xor_adr function

"""

def xor_round_key(block,key):
    block[0][0] = block[0][0]^key[0]
    block[0][1] = block[0][1]^key[4]
    block[0][2] = block[0][2]^key[8]
    block[0][3] = block[0][3]^key[12]
    block[1][0] = block[1][0]^key[1]
    block[1][1] = block[1][1]^key[5]
    block[1][2] = block[1][2]^key[9]
    block[1][3] = block[1][3]^key[13]
    block[2][0] = block[2][0]^key[2]
    block[2][1] = block[2][1]^key[6]
    block[2][2] = block[2][2]^key[10]
    block[2][3] = block[2][3]^key[14]
    block[3][0] = block[3][0]^key[3]
    block[3][1] = block[3][1]^key[7]
    block[3][2] = block[3][2]^key[11]
    block[3][3] = block[3][3]^key[15]

    return block
    
"""
    to_matrix()

    Params:
        - block (List representation of the 16 bytes to create a block)

    Walkthrough:
        - Create an empty matrix of 4 x 4
        - Append each 4 elements to a line and repeat for 4 steps
        - Return the block (The matrix)

"""

def to_matrix(block):
    matrix = [
        [ord(block[0]),ord(block[4]),ord(block[8]),ord(block[12])],
        [ord(block[1]),ord(block[5]),ord(block[9]),ord(block[13])],
        [ord(block[2]),ord(block[6]),ord(block[10]),ord(block[14])],
        [ord(block[3]),ord(block[7]),ord(block[11]),ord(block[15])]
    ]
    return matrix

"""
    myrand()

    Params:
        - d (Max range for random)

    Walkthrough:
        - Simple pseudo-number generator taken from https://stackoverflow.com/questions/15402326/simple-prng-algorithm-has-different-python-c-output-integer-overflow-differenc

"""

next = 0
modulo = 2**32
def myrand(d):
    global next
    next = ((next * 1103515245) + 12345) % modulo
    return int((next / 65536) % d)

"""
    shuffle_sub_bytes()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get the shuffled sbox generated
        - Switch each byte for the corresponding one in the shuffled sbox
        - Return the block

"""

def shuffle_sub_bytes(block):
    return [[shuffledsbox[x] for x in line] for line in block]

"""
    shuffle_shift_rows()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get the preloaded combination of all possible permutaions for shifts
        - Get an equally provable number from the shuffled key and get the corresponding permutation
        - Iterate over the lines and apply the shift to all rows using the shift_list function
        - Return the block

"""

def shuffle_shift_rows(block):
    perms = permutations[get_offset_from_key(23)]
    return [line[perms[c]:]+line[:perms[c]] for c,line in enumerate(block)]

"""
    shuffle_mix_cols()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get an equally provable number from the shuffled key
        - Mix the columns using the mix_columns function
        - Add offset to all the rows shifting each column
        - Return the block

"""


def shuffle_mix_cols(block):
    offset = get_offset_from_key(3)
    block = mix_columns(block)
    return [line[offset:]+line[:offset] for line in block]

"""
    shuffle_xor_round_key()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)
        - k (Encryption key used for this round)

    Walkthrough:
        - Get the shuffle key
        - Shift the encryption key using an equall provable number from the shuffle key
        - Return the xor with the round key of the block using xor_round_key()

"""

def shuffle_xor_round_key(block,k):
    offset_key = shift_list(k,get_offset_from_key(15))
    return xor_round_key(block,offset_key)

"""
    saes_encrypt()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get all the 11 keys for SAES encryption
        - Get the shuffle round using an equall provable number from the shuffle key
        - Xor the block with the first key
        - Beging a loop where:
            - Rounds that aren't the shuffle one mix the block using sub_bytes(), shuffle_rows(),mix_columns() 
                and xor_round_key()
            - The shuffle round used the shuffled counter parts of the above functions
        - The last round consists of a sub_bytes() followed by a shift_rows() and a final xor with the last key
        - Prints the result of the encrypted block to stdout

"""

def saes_encrypt(block):
    sr = get_offset_from_key(9)
    
    block = xor_round_key(block,keys[0])
    for i in range(1,10):
        if i == sr:
            block = shuffle_sub_bytes(block)
            block = shuffle_shift_rows(block)
            block = shuffle_mix_cols(block)
            block = shuffle_xor_round_key(block,keys[i])
        else:
            block = sub_bytes(block)
            block = shift_rows(block)
            block = mix_columns(block)
            block = xor_round_key(block,keys[i])
    block = sub_bytes(block)
    block = shift_rows(block)
    block = xor_round_key(block,keys[10])

    print(chr(block[0][0]),end="")
    print(chr(block[1][0]),end="")
    print(chr(block[2][0]),end="")
    print(chr(block[3][0]),end="")
    print(chr(block[0][1]),end="")
    print(chr(block[1][1]),end="")
    print(chr(block[2][1]),end="")
    print(chr(block[3][1]),end="")
    print(chr(block[0][2]),end="")
    print(chr(block[1][2]),end="")
    print(chr(block[2][2]),end="")
    print(chr(block[3][2]),end="")
    print(chr(block[0][3]),end="")
    print(chr(block[1][3]),end="")
    print(chr(block[2][3]),end="")
    print(chr(block[3][3]),end="")

"""
    pad_block()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get the number of missing elements to create a 4 by 4 block
        - Add padded list
        - Return the block

"""

def pad_block(block):
    pad = 16 - len(block)
    return block + [chr(pad)]*pad

"""
    unpad()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get the padding from the last item in the block
        - Remove that amount of bytes fcount from the end

"""

def unpad(s):
    pad = 16 - ord(s[-1])
    return s[:pad]

"""
    get_offset_from_key()

    Params:
        - n (Max number to extract - 1)

    Walkthrough:
        - Get the shuffle key
        - Sum the values of the shuffle key
        - Return the mod of the sum +1 (Because during the program 0 isn't usefull)

"""

def get_offset_from_key(n):
    if sk == []: return -1
    return (sum(sk) % n) +1

"""
    make_shuffledsbox()
    Taken from: https://stackoverflow.com/questions/40961518/fisher-yates-shuffle-in-python

    Params:
        None

    Walkthrough:
        - Perform the fisher-yates algorithm on the sbox

"""

def make_shuffledsbox():
    global shuffledsbox
    shuffledsbox = [x for x in sbox]
    a=len(sbox)
    b=a-1
    for d in range(b,0,-1):
        e=myrand(d)
        if e == d:
            continue
        shuffledsbox[d],shuffledsbox[e]=shuffledsbox[e],shuffledsbox[d]
    return shuffledsbox

"""
    make_shuffledrsbox()

    Params:
        None

    Walkthrough:
        - Get the shuffledsbox and the shuffledrsbox
        - Interate over the shuffledsbox and place the shuffledsbox[i] and the shuffledrsbox creating the
            inverse box

"""

def make_shuffledrsbox():
    global shuffledsbox
    global shuffledrsbox

    for i in range(256):
        s = shuffledsbox.index(i)
        shuffledrsbox.append(s)

"""
    make_keys()

    Params:
        None

    Walkthrough:
        - Get the arguments
        - Digest both
        - Pass from hex to int
        - Generate words and keys

"""

get_bin = lambda x: format(x, 'b')

def make_keys(flag,normal,shuflle):
    global keys
    global sk
    global next
    enc_key = normal
    digest_enc_key = hashlib.md5(enc_key.encode()).hexdigest()
    enc_key_final = []
    for i in range(len(digest_enc_key)):
        enc_key_final.append(hex_matcher(digest_enc_key[i]))
    w = keyExpansion([ enc_key_final[i]*16 + enc_key_final[i+1] for i in range(0,len(digest_enc_key),2)])
    keys = [list(w[i]) + list(w[i+1]) + list(w[i+2]) + list(w[i+3])  for i in range(0,11*4,4)]
    if flag == 1:
        shuffle_key = shuflle
        digest_shuffle_key = hashlib.md5(shuffle_key.encode()).hexdigest()
        shuffle_key_final = []
        for i in range(len(digest_enc_key)):
            shuffle_key_final.append(hex_matcher(digest_shuffle_key[i]))
        sk = shuffle_key_final
        sk_st = ""
        for i in sk:
            sk_st += get_bin(i)
        count = 128
        for i in sk_st:
            if i == "1":
                next += 2** count
            count -=1

"""
    shuffle_inv_sub_bytes()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get the inversed shuffled sbox generated
        - Switch each byte for the corresponding one in the inverted shuffled sbox
        - Return the block

"""

def shuffle_inv_sub_bytes(block):
     return [[shuffledrsbox[x] for x in line] for line in block]

"""
    shuffle_inv_mix_cols()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get an equally provable number from the shuffled key
        - Unshift the colmns by creating the inverse offset used
        - Reverse the mix columns operation using inv_mix_columns function
        - Return the block

"""

def shuffle_inv_mix_cols(block):
    offset = get_offset_from_key(3)
    block = [line[4-offset:]+line[:4-offset] if offset != 0 else line[offset:]+line[:offset] for line in block]
    block = inv_mix_columns(block)
    return block

"""
    shuffle_xor_round_key()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)
        - k (Encryption key used for this round)

    Walkthrough:
        - Get the shuffle key
        - Shift the encryption key using an equal provable number from the shuffle key
        - Return the xor with the round key of the block using xor_round_key()

"""

def shuffle_xor_round_key(block,k):
    offset_key = shift_list(k,get_offset_from_key(15))
    return xor_round_key(block,offset_key)

"""
    shuffle_xor_round_key()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get the shuffle key
        - Calculate the permutation used for encryption round
        - Get the inverse permutations and apply them to each row
        - Return the block

"""

def shuffle_inv_shift_rows(block):
    perms = permutations[get_offset_from_key(23)]
    perms = [4-x if x != 0 else 0 for x in perms ]
    return [line[perms[c]:]+line[:perms[c]] for c,line in enumerate(block)]

"""
    saes_decrypt()

    Params:
        - block (Representation of the current block using a 4 by 4 grid)

    Walkthrough:
        - Get all the 11 keys for SAES encryption
        - Get the shuffle round using an equall provable number from the shuffle key
        - Xor the block with the last key
        - Beging a loop where:
            - Rounds that aren't the shuffle one unmix the block using inv_inv_sub_bytes(), inv_shuffle_rows(), 
                inv_mix_columns(), and xor_round_key()
            - The shuffle round used the shuffled counter parts of the above functions but in the decryption there is 
                a catch since the decryption flow is not simetrical with the ecnryption one so the shuffle round
                decryption needs to be embedded in the middle of the following normal round of AES
        - The last round consists of a inv_shift_rows() followed by a inv_sub_bytes() and a final xor with the first key
        - Returns the block decrypted

"""

def saes_decrypt(block):
    sr = get_offset_from_key(9)

    block = xor_round_key(block,keys[10])
    for i in range(1,10):
        if i == 10-sr:
            block = inv_shift_rows(block)
            block = inv_sub_bytes(block)
            block = shuffle_xor_round_key(block,keys[10-i])
            block = shuffle_inv_mix_cols(block)
            block = shuffle_inv_shift_rows(block)
            block = shuffle_inv_sub_bytes(block)
            block = xor_round_key(block,keys[10-i-1])
            block = inv_mix_columns(block)
        elif i == 10 -sr +1:
            continue
        else:    
            block = inv_shift_rows(block)
            block = inv_sub_bytes(block)
            block = xor_round_key(block,keys[10-i])
            block = inv_mix_columns(block)
    block = inv_shift_rows(block)
    block = inv_sub_bytes(block)
    block = xor_round_key(block,keys[0])

    res=""
    for i in range(4):
        for c in range(4):
            res += chr(block[c][i])

    return res